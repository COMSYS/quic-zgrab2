//go:build linux
// +build linux

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -target bpf -tags linux filter ecn_filter.c -- -O2 -Wall -Wextra -mcpu=v2

package tcpinfo

import (
	"encoding/binary"
	"errors"
	"log"
	"net"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"golang.org/x/sys/unix"
)

// Layout must be byte-identical to struct ecn_count from ecn_filter.c!
// Follow unix.TCPInfo casing convention
type ecnCount struct {
	Packets_Notect   uint32
	Packets_Ect1     uint32
	Packets_Ect0     uint32
	Packets_Ce       uint32
	Synack_Ececwr    uint32
	Packets_Ececwr   uint32
	Packets_Noececwr uint32
	Packets_Ecenocwr uint32
}

// (Currently) not generated by bpf2go
func loadFilterSpecs() (fs filterSpecs, spec *ebpf.CollectionSpec, err error) {
	if spec, err = loadFilter(); err == nil {
		err = spec.Assign(&fs)
	}
	return
}

func (fs filterMapSpecs) verifyElementSize() {
	// ebpf internally uses encoding/binary to (un)marshal
	siz := binary.Size(ecnCount{})
	if fs.EcnStore.ValueSize != uint32(siz) {
		log.Fatalf("TCPInfoService BUG: ecnCount size differs (bpf=%d Go=%d)", fs.EcnStore.ValueSize, siz)
	}
}

type TCPInfo struct {
	unix.TCPInfo
	ecnCount
	Ecn_Fallback bool
	SrcPort      int
}

type TCPInfoService struct {
	filter filterObjects
}

// max_socks == 0 disables BPF features
func NewTCPInfoService(max_socks uint32) (*TCPInfoService, error) {
	var svc TCPInfoService
	if max_socks == 0 {
		return &svc, nil
	}

	fs, spec, err := loadFilterSpecs()
	if err != nil {
		return nil, err
	}
	fs.verifyElementSize()
	fs.EcnStore.MaxEntries = max_socks

	if err := spec.LoadAndAssign(&svc.filter, nil); err != nil {
		return nil, err
	}
	return &svc, nil
}

func (svc *TCPInfoService) Close() error {
	return svc.filter.Close()
}

func (svc *TCPInfoService) hasBPF() bool {
	// We load either all or none of the BPF objects, so checking one suffices
	return svc.filter.CountEcn != nil
}

func (svc *TCPInfoService) RegisterConn(c net.Conn) error {
	if !svc.hasBPF() {
		return nil
	}

	sc, err := unwrapSyscallConn(c)
	if err == nil {
		err = link.AttachSocketFilter(sc, svc.filter.CountEcn)
	}
	return err
}

func (svc *TCPInfoService) DeregisterConn(c net.Conn) (err error) {
	if !svc.hasBPF() {
		return
	}

	rawConn, err := unwrapRawConn(c)
	if err != nil {
		return
	}

	var sockid uint64
	if err2 := rawConn.Control(func(fd uintptr) {
		err = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_DETACH_BPF, 0)
		if err == nil {
			sockid, err = unix.GetsockoptUint64(int(fd), unix.SOL_SOCKET, unix.SO_COOKIE)
		}
	}); err != nil || err2 != nil {
		if err == nil {
			err = err2
		}
		return
	}

	// Delete after detaching to ensure entry is not recreated
	err = svc.filter.EcnStore.Delete(sockid)
	if err != nil && errors.Is(err, ebpf.ErrKeyNotExist) {
		err = nil
	}
	return
}

func (svc *TCPInfoService) GetTCPInfo(c net.Conn) (info *TCPInfo, err error) {
	rawConn, err := unwrapRawConn(c)
	if err != nil {
		return
	}

	var sockid uint64
	var srcport int
	var tcp *unix.TCPInfo
	if err2 := rawConn.Control(func(fd uintptr) {
		sockid, err = unix.GetsockoptUint64(int(fd), unix.SOL_SOCKET, unix.SO_COOKIE)
		if err == nil {
			tcp, err = unix.GetsockoptTCPInfo(int(fd), unix.IPPROTO_TCP, unix.TCP_INFO)
		}
		sa, err := unix.Getsockname(int(fd))
		srcport = 0
		if err == nil {
			switch v := sa.(type) {
			case *unix.SockaddrInet4:
				srcport = v.Port
			case *unix.SockaddrInet6:
				srcport = v.Port
			default:
				srcport = 0
			}
		}
	}); err != nil || err2 != nil {
		if err == nil {
			err = err2
		}
		return
	}

	info = &TCPInfo{TCPInfo: *tcp, SrcPort: srcport}
	if svc.hasBPF() {
		err = svc.filter.EcnStore.Lookup(sockid, &info.ecnCount)
		if err != nil && errors.Is(err, ebpf.ErrKeyNotExist) {
			// Not an error: missing entries are all-zero (default value)
			err = nil
		} // else: return partial TCPInfo *and* report error
	}
	return
}

// From <linux/tcp.h>
const TCPI_OPT_ECN = 8

// May only be called before transmitting any data on c
func DidECNFallback(c net.Conn) (fb bool, err error) {
	rawConn, err := unwrapRawConn(c)
	if err != nil {
		return
	}

	if err2 := rawConn.Control(func(fd uintptr) {
		var tcp *unix.TCPInfo
		tcp, err = unix.GetsockoptTCPInfo(int(fd), unix.IPPROTO_TCP, unix.TCP_INFO)
		if err == nil {
			// The only retransmissions at this point were SYNs.
			// Thus, if ECN was not negotiated, ECN fallback took place.
			// (Assuming that ECN negotiation was attempted)
			fb = tcp.Total_retrans > 0 && (tcp.Options&TCPI_OPT_ECN == 0)
		}
	}); err2 != nil && err == nil {
		err = err2
	}
	return
}
